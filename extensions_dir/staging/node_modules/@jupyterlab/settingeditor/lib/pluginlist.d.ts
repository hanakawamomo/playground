/// <reference types="react" />
import { ReactWidget } from '@jupyterlab/apputils';
import { ISettingRegistry } from '@jupyterlab/settingregistry';
import { ITranslator } from '@jupyterlab/translation';
import { Message } from '@lumino/messaging';
import { ISignal } from '@lumino/signaling';
/**
 * A list of plugins with editable settings.
 */
export declare class PluginList extends ReactWidget {
    /**
     * Create a new plugin list.
     */
    constructor(options: PluginList.IOptions);
    /**
     * The setting registry.
     */
    readonly registry: ISettingRegistry;
    /**
     * A signal emitted when a list user interaction happens.
     */
    get changed(): ISignal<this, void>;
    /**
     * The selection value of the plugin list.
     */
    get scrollTop(): number | undefined;
    get hasErrors(): boolean;
    /**
     * The selection value of the plugin list.
     */
    get selection(): string;
    set selection(selection: string);
    get filter(): (item: ISettingRegistry.IPlugin) => boolean;
    set filter(filter: (item: ISettingRegistry.IPlugin) => boolean);
    protected updateModifiedPlugins(): Promise<void>;
    get handleSelectSignal(): ISignal<this, string>;
    /**
     * Handle `'update-request'` messages.
     */
    protected onUpdateRequest(msg: Message): void;
    /**
     * Handle the `'mousedown'` event for the plugin list.
     *
     * @param event - The DOM event sent to the widget
     */
    private _evtMousedown;
    /**
     * Check the plugin for a rendering hint's value.
     *
     * #### Notes
     * The order of priority for overridden hints is as follows, from most
     * important to least:
     * 1. Data set by the end user in a settings file.
     * 2. Data set by the plugin author as a schema default.
     * 3. Data set by the plugin author as a top-level key of the schema.
     */
    getHint(key: string, registry: ISettingRegistry, plugin: ISettingRegistry.IPlugin): string;
    setFilter(filter: (item: string) => boolean): void;
    setError(id: string, error: boolean): void;
    mapPlugins(plugin: ISettingRegistry.IPlugin): JSX.Element;
    render(): JSX.Element;
    protected translator: ITranslator;
    private _changed;
    private _errors;
    private _filter;
    private _handleSelectSignal;
    private _modifiedPlugins;
    private _allPlugins;
    private _confirm?;
    private _scrollTop;
    private _selection;
}
/**
 * A namespace for `PluginList` statics.
 */
export declare namespace PluginList {
    /**
     * The instantiation options for a plugin list.
     */
    interface IOptions {
        /**
         * A function that allows for asynchronously confirming a selection.
         *
         * #### Notes
         * If the promise returned by the function resolves, then the selection will
         * succeed and emit an event. If the promise rejects, the selection is not
         * made.
         */
        confirm?: (id: string) => Promise<void>;
        /**
         * The setting registry for the plugin list.
         */
        registry: ISettingRegistry;
        /**
         * List of plugins to skip
         */
        toSkip?: string[];
        /**
         * The setting registry for the plugin list.
         */
        translator?: ITranslator;
    }
    /**
     * Sort a list of plugins by title and ID.
     */
    function sortPlugins(registry: ISettingRegistry): ISettingRegistry.IPlugin[];
}
