/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/
import { showErrorMessage } from '@jupyterlab/apputils';
import { caretDownIcon, caretRightIcon } from '@jupyterlab/ui-components';
import { reduce } from '@lumino/algorithm';
import { JSONExt } from '@lumino/coreutils';
import { Debouncer } from '@lumino/polling';
import Form, { utils } from '@rjsf/core';
import React from 'react';
/**
 * Indentation to use when saving the settings as JSON document.
 */
const JSON_INDENTATION = 4;
/**
 * Template to allow for custom buttons to re-order/remove entries in an array.
 * Necessary to create accessible buttons.
 */
const CustomArrayTemplateFactory = (translator) => {
    const trans = translator.load('jupyterlab');
    const factory = (props) => {
        var _a;
        return (React.createElement("div", { className: props.className },
            React.createElement(props.TitleField, { title: props.title, required: props.required, id: `${props.idSchema.$id}-title` }),
            React.createElement(props.DescriptionField, { id: `${props.idSchema.$id}-description`, description: (_a = props.schema.description) !== null && _a !== void 0 ? _a : '' }),
            props.items.map(item => {
                return (React.createElement("div", { key: item.key, className: item.className },
                    item.children,
                    React.createElement("div", { className: "jp-ArrayOperations" },
                        React.createElement("button", { className: "jp-mod-styled jp-mod-reject", onClick: item.onReorderClick(item.index, item.index - 1), disabled: !item.hasMoveUp }, trans.__('Move Up')),
                        React.createElement("button", { className: "jp-mod-styled jp-mod-reject", onClick: item.onReorderClick(item.index, item.index + 1), disabled: !item.hasMoveDown }, trans.__('Move Down')),
                        React.createElement("button", { className: "jp-mod-styled jp-mod-warn", onClick: item.onDropIndexClick(item.index), disabled: !item.hasRemove }, trans.__('Remove')))));
            }),
            props.canAdd && (React.createElement("button", { className: "jp-mod-styled jp-mod-reject", onClick: props.onAddClick }, trans.__('Add')))));
    };
    factory.displayName = 'CustomArrayTemplate';
    return factory;
};
/**
 * Template with custom add button, necessary for accessiblity and internationalization.
 */
const CustomObjectTemplateFactory = (translator) => {
    const trans = translator.load('jupyterlab');
    const factory = (props) => {
        const { TitleField, DescriptionField } = props;
        return (React.createElement("fieldset", { id: props.idSchema.$id },
            (props.uiSchema['ui:title'] || props.title) && (React.createElement(TitleField, { id: `${props.idSchema.$id}__title`, title: props.title || props.uiSchema['ui:title'], required: props.required })),
            props.description && (React.createElement(DescriptionField, { id: `${props.idSchema.$id}__description`, description: props.description })),
            props.properties.map(property => property.content),
            utils.canExpand(props.schema, props.uiSchema, props.formData) && (React.createElement("button", { className: "jp-mod-styled jp-mod-reject", onClick: props.onAddClick(props.schema), disabled: props.disabled || props.readonly }, trans.__('Add')))));
    };
    factory.displayName = 'CustomObjectTemplate';
    return factory;
};
/**
 * Renders the modified indicator and errors
 */
const CustomTemplate = (props) => {
    const { formData, schema, label, displayLabel, id, formContext, errors, rawErrors, children, onKeyChange, onDropPropertyClick } = props;
    /**
     * Determine if the field has been modified
     * Schema Id is formatted as 'root_<field name>.<nexted field name>'
     * This logic parses out the field name to find the default value
     * before determining if the field has been modified.
     */
    const schemaIds = id.split('_');
    schemaIds.shift();
    const schemaId = schemaIds.join('.');
    let defaultValue;
    if (schemaIds.length === 1) {
        defaultValue = formContext.settings.default(schemaId);
    }
    else if (schemaIds.length > 1) {
        const allDefaultsForObject = {};
        allDefaultsForObject[schemaIds[0]] = formContext.settings.default(schemaIds[0]);
        defaultValue = reduce(schemaIds, (acc, val, i) => {
            return acc === null || acc === void 0 ? void 0 : acc[val];
        }, allDefaultsForObject);
    }
    const isModified = schemaId !== '' &&
        formData !== undefined &&
        defaultValue !== undefined &&
        !schema.properties &&
        schema.type !== 'array' &&
        !JSONExt.deepEqual(formData, defaultValue);
    const isRoot = schemaId === '';
    const needsDescription = !isRoot &&
        schema.type != 'object' &&
        id !=
            'jp-SettingsEditor-@jupyterlab/shortcuts-extension:shortcuts_shortcuts';
    // While we can implement "remove" button for array items in array template,
    // object templates do not provide a way to do this; instead we need to add
    // buttons here (and first check if the field can be removed = is additional).
    const isAdditional = schema.hasOwnProperty(utils.ADDITIONAL_PROPERTY_FLAG);
    return (React.createElement("div", { className: `form-group ${displayLabel || schema.type === 'boolean' ? 'small-field' : ''}` },
        // Only show the modified indicator if there are no errors
        isModified && !rawErrors && React.createElement("div", { className: "jp-modifiedIndicator" }),
        // Shows a red indicator for fields that have validation errors
        rawErrors && React.createElement("div", { className: "jp-modifiedIndicator jp-errorIndicator" }),
        React.createElement("div", { className: "jp-FormGroup-content" },
            displayLabel && !isRoot && label && !isAdditional && (React.createElement("h3", { className: "jp-FormGroup-fieldLabel jp-FormGroup-contentItem" }, label)),
            isAdditional && (React.createElement("input", { className: "jp-FormGroup-contentItem jp-mod-styled", type: "text", onBlur: event => onKeyChange(event.target.value), defaultValue: label })),
            React.createElement("div", { className: `${isRoot
                    ? 'jp-root'
                    : schema.type === 'object'
                        ? 'jp-objectFieldWrapper'
                        : 'jp-inputFieldWrapper jp-FormGroup-contentItem'}` }, children),
            isAdditional && (React.createElement("button", { className: "jp-FormGroup-contentItem jp-mod-styled jp-mod-warn jp-FormGroup-removeButton", onClick: onDropPropertyClick(label) }, 'Remove')),
            schema.description && needsDescription && (React.createElement("div", { className: "jp-FormGroup-description" }, schema.description)),
            React.createElement("div", { className: "validationErrors" }, errors))));
};
/**
 * A React component that prepares the settings for a
 * given plugin to be rendered in the FormEditor.
 */
export class SettingsFormEditor extends React.Component {
    constructor(props) {
        super(props);
        /**
         * Handler for the "Restore to defaults" button - clears all
         * modified settings then calls `setFormData` to restore the
         * values.
         */
        this.reset = async () => {
            for (const field in this.props.settings.user) {
                await this.props.settings.remove(field);
            }
            this.setState({
                formData: this.props.settings.composite,
                isModified: false
            });
        };
        this.onSelect = (list, id) => {
            if (id === this.props.settings.id) {
                this.props.onCollapseChange(false);
            }
        };
        const { settings } = props;
        this.state = {
            formData: settings.composite,
            isModified: settings.isModified
        };
        this.handleChange = this.handleChange.bind(this);
        this._debouncer = new Debouncer(this.handleChange);
    }
    /**
     * Handler for edits made in the form editor.
     * @param data - Form data sent from the form editor
     */
    handleChange() {
        // Prevent unnecessary save when opening settings that haven't been modified.
        if (!this.props.settings.isModified &&
            this.props.settings.isDefault(this.state.formData)) {
            this.props.updateDirtyState(false);
            return;
        }
        this.props.settings
            .save(JSON.stringify(this.state.formData, undefined, JSON_INDENTATION))
            .then(() => {
            this.props.updateDirtyState(false);
            this.setState({ isModified: this.props.settings.isModified });
        })
            .catch((reason) => {
            this.props.updateDirtyState(false);
            const trans = this.props.translator.load('jupyterlab');
            showErrorMessage(trans.__('Error saving settings.'), reason);
        });
    }
    render() {
        var _a;
        const trans = this.props.translator.load('jupyterlab');
        /**
         * Construct uiSchema to pass any custom renderers to the form editor.
         */
        const uiSchema = {};
        for (const id in this.props.renderers) {
            if (Object.keys((_a = this.props.settings.schema.properties) !== null && _a !== void 0 ? _a : {}).includes(id)) {
                uiSchema[id] = {
                    'ui:field': id
                };
            }
        }
        const icon = this.props.isCollapsed ? caretRightIcon : caretDownIcon;
        return (React.createElement("div", null,
            React.createElement("div", { className: "jp-SettingsHeader", onClick: () => {
                    this.props.onCollapseChange(!this.props.isCollapsed);
                    this.props.onSelect(this.props.settings.id);
                } },
                React.createElement("header", { className: "jp-SettingsTitle" },
                    React.createElement(icon.react, { tag: "span", elementPosition: "center", className: "jp-SettingsTitle-caret" }),
                    React.createElement("h2", null, this.props.settings.schema.title),
                    React.createElement("div", { className: "jp-SettingsHeader-description" }, this.props.settings.schema.description)),
                this.state.isModified && (React.createElement("button", { className: "jp-RestoreButton", onClick: this.reset }, trans.__('Restore to Defaults')))),
            !this.props.isCollapsed && (React.createElement(Form, { schema: this.props.settings.schema, formData: this.state.formData, FieldTemplate: CustomTemplate, ArrayFieldTemplate: CustomArrayTemplateFactory(this.props.translator), ObjectFieldTemplate: CustomObjectTemplateFactory(this.props.translator), uiSchema: uiSchema, fields: this.props.renderers, formContext: { settings: this.props.settings }, liveValidate: true, idPrefix: `jp-SettingsEditor-${this.props.settings.id}`, onChange: (e) => {
                    this.props.hasError(e.errors.length !== 0);
                    this.setState({ formData: e.formData });
                    if (e.errors.length === 0) {
                        this.props.updateDirtyState(true);
                        void this._debouncer.invoke();
                    }
                    this.props.onSelect(this.props.settings.id);
                } }))));
    }
}
//# sourceMappingURL=SettingsFormEditor.js.map