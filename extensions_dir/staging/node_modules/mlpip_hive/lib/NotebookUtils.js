import { INotification } from 'jupyterlab_toastify';
export const DBX_CONTROL_PREFIX = '[__DBX__]';
export function executePython(kernel, code, outputFunc, controlFunc) {
    return new Promise((resolve, reject) => {
        const callbacks = (msg) => {
            const msgType = msg.header.msg_type;
            switch (msgType) {
                case 'execute_result':
                case 'display_data':
                case 'update_display_data':
                case 'status':
                case 'stream':
                    {
                        var output = msg.content;
                        const text = output.text.toLocaleString();
                        text
                            .trim()
                            .split('\n')
                            .forEach((line) => {
                            if (line.startsWith(DBX_CONTROL_PREFIX)) {
                                const control = JSON.parse(line.slice(DBX_CONTROL_PREFIX.length));
                                console.debug('control', control);
                                if (controlFunc != null) {
                                    controlFunc(control);
                                }
                                if (control.status == 'completed') {
                                    resolve(control);
                                }
                            }
                            else {
                                console.debug(line);
                                if (outputFunc != null) {
                                    outputFunc(line);
                                }
                            }
                        });
                    }
                    break;
                case 'error':
                    {
                        console.debug(msg);
                        reject(msg);
                    }
                    break;
                case 'execute_input':
                    break;
                default: {
                    console.warn('Unknown type of message', msg);
                }
            }
        };
        var future = kernel.requestExecute({ code });
        future.onIOPub = callbacks;
    });
}
export function stripAnsi(text) {
    const pattern = [
        '[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
        '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
    ].join('|');
    const regex = new RegExp(pattern, 'g');
    return text.replace(regex, '');
}
export function logServerException(err) {
    console.error(`${err.ename}: ${err.evalue}`);
    console.error(err.traceback.map(stripAnsi).join('\n'));
}
export function showErrorToast(notifier_id, reason) {
    INotification.update({
        toastId: notifier_id,
        message: reason,
        type: "error",
        buttons: [
            {
                label: "Close",
                callback: () => {
                    INotification.dismiss(notifier_id);
                }
            }
        ]
    });
}
