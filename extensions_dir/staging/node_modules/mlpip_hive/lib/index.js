import { DisposableDelegate } from '@lumino/disposable';
import { getSparkButton } from './hive';
import { CreateVenv, getPackageInstallerButton, getVenvButton } from './venv';
import { docMenuExtension } from './menu';
import * as NotebookCell from '@jupyterlab/cells/lib/widget';
import { INotification } from 'jupyterlab_toastify';
import { getServerCloneButton } from './git';
import { createMagicSwitcher } from './MagicSwitcher';
/**
* The plugin registration information.
*/
const plugin = {
    activate,
    id: 'my-extension-name:buttonPlugin',
    autoStart: true
};
/**
 * A notebook widget extension that adds Dbx specific functionality
 */
export class CustomDbxExtension {
    constructor(commands) {
        this._commands = commands;
    }
    /**
     * Create a new extension object.
     */
    createNew(panel, context) {
        let venv_button_class = "recreate_venv";
        let install_button_class = "install_packages";
        let spark_button_class = "connect_to_spark";
        let git_clone_button_class = "git_clone";
        var buttons = [];
        context.ready.then(() => {
            if (context.contentsModel.writable) {
                buttons = [
                    {
                        className: venv_button_class,
                        button: getVenvButton(panel.sessionContext, context, venv_button_class)
                    },
                    {
                        className: install_button_class,
                        button: getPackageInstallerButton(panel.sessionContext, context, install_button_class)
                    },
                    {
                        className: spark_button_class,
                        button: getSparkButton(panel, context, spark_button_class)
                    },
                    {
                        className: git_clone_button_class,
                        button: getServerCloneButton(panel.sessionContext, git_clone_button_class, this._commands)
                    }
                ];
                buttons.reverse();
                buttons.forEach(element => panel.toolbar.insertItem(10, element.className, element.button));
                panel.toolbar.insertAfter(git_clone_button_class, "magic_switcher", createMagicSwitcher(panel));
                panel.sessionContext.ready.then(() => {
                    panel.sessionContext.session.kernel.registerCommTarget('kernel_notification_comm', (comm) => {
                        // just log it to console as showing a toast for this is tricky
                        comm.onMsg = (recieved_msg) => console.log(recieved_msg.content.data);
                    });
                    if (panel.isVisible) {
                        CreateVenv(panel.sessionContext, context);
                    }
                    panel.sessionContext.kernelChanged.connect((sessionContext, kernelConnection) => sessionContext.isReady && !sessionContext.isDisposed && kernelConnection.newValue && CreateVenv(sessionContext, context));
                });
            }
            else {
                panel.toolbar.hide();
                panel.context.model.readOnly = true; // document in read-only mode
                var old_execute = NotebookCell.CodeCell.execute;
                NotebookCell.CodeCell.execute = async (codecell, sessionContext, obj) => {
                    if (codecell.readOnly) {
                        INotification.error("Read-only notebook. Cannot execute or save notebook", { autoClose: 3000 });
                    }
                    else {
                        old_execute(codecell, sessionContext, obj);
                    }
                };
                panel.content.widgets.forEach((c) => c.readOnly = true); //Cells in read-only mode
                context.model.cells.changed.connect((cellsList, args) => {
                    var readOnly = false;
                    for (var i = 0; i < cellsList.length; i++) {
                        if (panel.content.widgets[i].readOnly) {
                            readOnly = true;
                            break;
                        }
                    }
                    if (readOnly) {
                        if (args.type == "add") {
                            args.newValues.forEach(() => {
                                panel.content.widgets[args.newIndex].readOnly = true;
                            });
                        }
                    }
                });
            }
        });
        return new DisposableDelegate(() => {
            buttons.forEach(element => element.button.dispose());
        });
    }
}
/**
 * Activate the extension.
 */
function activate(app) {
    const { commands } = app;
    // @ts-ignore
    app.docRegistry.addWidgetExtension('Notebook', new CustomDbxExtension(commands));
}
;
/**
* Export the plugin as default.
*/
export default [plugin, docMenuExtension];
