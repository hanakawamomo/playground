"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextAnnotationView = exports.TextAnnotationModel = void 0;
const base_1 = require("@jupyter-widgets/base");
const version_1 = require("./version");
require("../css/widget.css");
const icons_1 = require("./icons");
const utils_1 = require("./utils");
class TextAnnotationModel extends base_1.DOMWidgetModel {
    defaults() {
        return Object.assign(Object.assign({}, super.defaults()), { _model_name: TextAnnotationModel.model_name, _model_module: TextAnnotationModel.model_module, _model_module_version: TextAnnotationModel.model_module_version, _view_name: TextAnnotationModel.view_name, _view_module: TextAnnotationModel.view_module, _view_module_version: TextAnnotationModel.view_module_version, texts: ['No text provided'], _current_text_idx: 0, labels: [], results: {} });
    }
}
exports.TextAnnotationModel = TextAnnotationModel;
TextAnnotationModel.serializers = Object.assign({}, base_1.DOMWidgetModel.serializers
// Add any extra serializers here
);
TextAnnotationModel.model_name = 'TextAnnotationModel';
TextAnnotationModel.model_module = version_1.MODULE_NAME;
TextAnnotationModel.model_module_version = version_1.MODULE_VERSION;
TextAnnotationModel.view_name = 'TextAnnotationView '; // Set to null if no view
TextAnnotationModel.view_module = version_1.MODULE_NAME; // Set to null if no view
TextAnnotationModel.view_module_version = version_1.MODULE_VERSION;
class TextAnnotationView extends base_1.DOMWidgetView {
    _createTextArea() {
        const div = document.createElement('div');
        div.classList.add('ta-text-area');
        return div;
    }
    _createNavButton(label) {
        const btn = document.createElement('button');
        btn.appendChild(document.createTextNode(label));
        btn.classList.add('ta-nav-btn');
        return btn;
    }
    _createLabelListPopup() {
        const labels = this.model.get('labels') || [];
        const popup = document.createElement('div');
        popup.classList.add('ta-label-list');
        labels.forEach((label, idx) => {
            const item = document.createElement('div');
            item.onclick = this._labelItemClicked.bind(this, idx, label);
            item.classList.add('ta-label-list-item');
            item.textContent = label;
            popup.appendChild(item);
        });
        return popup;
    }
    _removeLabel(label) {
        const textIdx = this.model.get('_current_text_idx');
        const results = utils_1.clone(this.model.get("results"));
        const labels = results[textIdx] || [];
        for (let i = 0; i < labels.length; i++) {
            if (labels[i].start == label.start && labels[i].end == label.end) {
                labels.splice(i, 1);
                break;
            }
        }
        results[textIdx] = labels;
        this.model.set("results", results);
        this.model.save_changes();
    }
    _createLabeledTextNode(label) {
        const textNode = document.createTextNode(label.text);
        const container = document.createElement('div');
        const labelNode = document.createElement('div');
        const closeBtn = document.createElement('div');
        closeBtn.innerHTML = icons_1.CLOSE_ICON;
        closeBtn.classList.add('ta-close');
        closeBtn.onclick = this._removeLabel.bind(this, label);
        labelNode.classList.add('ta-label');
        labelNode.textContent = label.label;
        container.classList.add('ta-labeled-text');
        container.dataset.textLength = String(label.text.length);
        container.appendChild(textNode);
        container.appendChild(labelNode);
        container.appendChild(closeBtn);
        return container;
    }
    _createHeader() {
        const header = document.createElement('h3');
        header.classList.add('ta-header');
        return header;
    }
    _renderHeader() {
        const textIdx = this.model.get('_current_text_idx');
        this._header.textContent = `Task ${textIdx}`;
    }
    _renderTextArea() {
        const textIdx = this.model.get('_current_text_idx');
        const texts = this.model.get('texts');
        const text = texts[textIdx];
        const results = this.model.get('results');
        const labels = results[textIdx] || [];
        const sortedLabels = utils_1.sortByKey(labels, 'start');
        // empty the entire text area
        var range = document.createRange();
        range.selectNodeContents(this._textArea);
        range.deleteContents();
        let currentLoc = 0;
        sortedLabels.forEach((label, labelIdx) => {
            if (currentLoc < label.start) {
                const textNode = document.createTextNode(text.substring(currentLoc, label.start));
                this._textArea.appendChild(textNode);
            }
            this._textArea.appendChild(this._createLabeledTextNode(label));
            currentLoc = label.end;
        });
        const textNode = document.createTextNode(text.substring(currentLoc, text.length));
        this._textArea.appendChild(textNode);
    }
    _textIdxUpdated() {
        this._renderHeader();
        this._renderTextArea();
    }
    render() {
        this._header = this._createHeader();
        this._textArea = this._createTextArea();
        this._prevBtn = this._createNavButton('Previous');
        this._nextBtn = this._createNavButton('Next');
        this._labelListPopup = this._createLabelListPopup();
        this.el.appendChild(this._header);
        this.el.appendChild(this._textArea);
        this.el.appendChild(this._prevBtn);
        this.el.appendChild(this._nextBtn);
        this.el.appendChild(this._labelListPopup);
        this.el.classList.add('ta-widget');
        // Python -> JavaScript update
        this.model.on('change:_current_text_idx', this._textIdxUpdated, this);
        this.model.on('change:results', this._renderTextArea, this);
        // JavaScript -> Python update
        this._prevBtn.onclick = this._onNavBtnClicked.bind(this, -1);
        this._nextBtn.onclick = this._onNavBtnClicked.bind(this, 1);
        this._textArea.onmouseup = this._onTextAreaMouseup.bind(this);
        this._textArea.onmousedown = this._hideLabelListPopup.bind(this);
        // initialize
        this._textIdxUpdated();
    }
    _labelItemClicked(labelIndex, label) {
        const results = utils_1.clone(this.model.get("results"));
        const textIdx = this.model.get('_current_text_idx');
        if (results[textIdx] == null) {
            results[textIdx] = [];
        }
        const labeledText = Object.assign(Object.assign({}, this._selectedText), { label });
        results[textIdx].push(labeledText);
        this.model.set("results", results);
        this.model.save_changes();
        this._hideLabelListPopup();
    }
    _isInTextArea(node) {
        if (node == null) {
            return false;
        }
        var parent = node.parentElement;
        return Boolean((parent === null || parent === void 0 ? void 0 : parent.classList.contains("ta-text-area")) && parent == this._textArea);
    }
    _calculateTextOffset(node) {
        let currentNode = node;
        let offset = 0;
        while (currentNode.previousSibling) {
            const sibling = currentNode.previousSibling;
            if (sibling instanceof HTMLElement && sibling.dataset.textLength) {
                offset += parseInt(sibling.dataset.textLength);
            }
            else if (currentNode.previousSibling.textContent) {
                offset += currentNode.previousSibling.textContent.length;
            }
            currentNode = currentNode.previousSibling;
        }
        return offset;
    }
    _updateSelectedText(sel) {
        var _a;
        const nodeOffset = this._calculateTextOffset(sel.anchorNode);
        console.log("text offset", nodeOffset);
        const start = nodeOffset + sel.anchorOffset;
        const end = nodeOffset + sel.focusOffset;
        const selectedText = (_a = this._getCurrentText()) === null || _a === void 0 ? void 0 : _a.substring(start, end);
        if (selectedText != null) {
            this._selectedText = {
                start, end, text: selectedText,
            };
        }
    }
    _onTextAreaMouseup() {
        const sel = document.getSelection();
        if (sel == null || sel.anchorNode == null || sel.focusNode == null) {
            this._hideLabelListPopup();
            return;
        }
        // start and end can't cross existing labels
        if (this._isInTextArea(sel.anchorNode) && this._isInTextArea(sel.focusNode) &&
            sel.anchorNode == sel.focusNode) {
            if (sel.anchorOffset == sel.focusOffset) {
                this._hideLabelListPopup();
            }
            else {
                this._updateSelectedText(sel);
                this._showLabelListPopup(sel.getRangeAt(0).getBoundingClientRect());
            }
        }
    }
    _showLabelListPopup(selectionRangeRect) {
        const widgetRect = this.el.getBoundingClientRect();
        const xOffset = 8;
        this._labelListPopup.style.left = String(selectionRangeRect.right - widgetRect.x + xOffset) + "px";
        this._labelListPopup.style.top = String(selectionRangeRect.y - widgetRect.y) + "px";
        this._labelListPopup.style.display = "block";
    }
    _hideLabelListPopup() {
        this._labelListPopup.style.display = "none";
    }
    _getCurrentText() {
        const idx = this.model.get('_current_text_idx');
        const texts = this.model.get('texts');
        if (idx >= 0 && idx < texts.length) {
            return texts[idx];
        }
        return null;
    }
    _onNavBtnClicked(offset) {
        const idx = this.model.get('_current_text_idx');
        const texts = this.model.get('texts');
        let newIdx;
        if (offset < 0) {
            newIdx = idx + offset < 0 ? texts.length - 1 : idx - 1;
        }
        else {
            newIdx = (idx + offset) % texts.length;
        }
        this.model.set('_current_text_idx', newIdx);
        this.model.save_changes();
    }
}
exports.TextAnnotationView = TextAnnotationView;
//# sourceMappingURL=widget.js.map